import { useCallback, useState } from 'react';

import { assetsService } from '@/api/assetsService';
import type { GenerateImageDescriptionResponse, ImageDescriptionStatus, UploadFileInfo } from '@/types/assets';

export interface UseImageUploadOptions {
  /** RPD类型，默认为 general_ng_review */
  rpdType?: string;
  /** RPD标题 */
  rpdTitle?: string;
  /** 上下文信息 */
  context?: string;
  /** 是否自动生成描述 */
  autoGenerateDescription?: boolean;
  /** 最大并发上传数量 */
  maxConcurrentUploads?: number;
  /** 会话ID（用于临时存储） */
  sessionId?: string;
  /** 是否使用临时存储，默认为false */
  useTempStorage?: boolean;
}

export interface UseImageUploadReturn {
  /** 上传的文件信息列表 */
  uploadedFiles: UploadFileInfo[];
  /** 正在上传的文件数量 */
  uploadingCount: number;
  /** 正在生成描述的文件数量 */
  generatingCount: number;
  /** 是否有任何文件正在处理中 */
  isProcessing: boolean;
  /** 上传并处理文件 */
  uploadFiles: (files: FileList | File[]) => Promise<void>;
  /** 重新生成特定文件的描述 */
  regenerateDescription: (fileId: string, context?: string) => Promise<void>;
  /** 移除文件 */
  removeFile: (fileId: string) => void;
  /** 清空所有文件 */
  clearFiles: () => void;
  /** 获取文件描述 */
  getFileDescription: (fileId: string) => GenerateImageDescriptionResponse | undefined;
  /** 更新文件状态 */
  updateFileStatus: (fileId: string, status: ImageDescriptionStatus, error?: string) => void;
}

export const useImageUpload = (options: UseImageUploadOptions = {}): UseImageUploadReturn => {
  const {
    rpdType = 'general_ng_review',
    rpdTitle = '',
    context,
    autoGenerateDescription = true,
    maxConcurrentUploads = 3,
    sessionId,
    useTempStorage = false,
  } = options;

  const [uploadedFiles, setUploadedFiles] = useState<UploadFileInfo[]>([]);

  // 生成唯一ID
  const generateId = useCallback(() => {
    return `file_${Date.now()}_${crypto.randomUUID().slice(0, 8)}`;
  }, []);

  // 创建blob URL用于预览
  const createPreviewUrl = useCallback((file: File): string => {
    return URL.createObjectURL(file);
  }, []);

  // 更新文件状态
  const updateFileStatus = useCallback((fileId: string, status: ImageDescriptionStatus, error?: string) => {
    setUploadedFiles((prev) =>
      prev.map((file) => (file.id === fileId ? { ...file, status, ...(error && { error }) } : file)),
    );
  }, []);

  // 更新文件描述
  const updateFileDescription = useCallback(
    (fileId: string, description: GenerateImageDescriptionResponse, s3Url?: string) => {
      setUploadedFiles((prev) =>
        prev.map((file) =>
          file.id === fileId
            ? { ...file, description, status: 'completed' as ImageDescriptionStatus, ...(s3Url && { s3Url }) }
            : file,
        ),
      );
    },
    [],
  );

  // 处理单个文件上传和描述生成
  const processFile = useCallback(
    async (fileInfo: UploadFileInfo) => {
      try {
        // 更新状态为上传中
        updateFileStatus(fileInfo.id, 'uploading');

        if (autoGenerateDescription) {
          // 使用完整流程：上传 + 生成描述
          if (useTempStorage && sessionId) {
            // 使用临时存储
            const result = await assetsService.uploadTempAndGenerateDescription(
              fileInfo.file,
              sessionId,
              context,
              rpdType,
              rpdTitle,
              (progress) => {
                console.log(`File ${fileInfo.id} temp upload progress: ${progress}%`);
              },
            );

            updateFileDescription(fileInfo.id, result.description, result.s3Url);
          } else {
            // 使用正式存储
            const result = await assetsService.uploadAndGenerateDescription(
              fileInfo.file,
              context,
              rpdType,
              rpdTitle,
              (progress) => {
                console.log(`File ${fileInfo.id} upload progress: ${progress}%`);
              },
            );

            updateFileDescription(fileInfo.id, result.description, result.s3Url);
          }
        } else {
          // 只上传文件
          updateFileStatus(fileInfo.id, 'generating');

          if (useTempStorage && sessionId) {
            // 上传到临时存储
            const uploadResult = await assetsService.uploadTempImage(fileInfo.file, sessionId);

            setUploadedFiles((prev) =>
              prev.map((file) =>
                file.id === fileInfo.id
                  ? { ...file, s3Url: uploadResult.url, status: 'completed' as ImageDescriptionStatus }
                  : file,
              ),
            );
          } else {
            // 上传到正式存储
            const uploadResult = await assetsService.uploadImage(fileInfo.file);

            setUploadedFiles((prev) =>
              prev.map((file) =>
                file.id === fileInfo.id
                  ? { ...file, s3Url: uploadResult.url, status: 'completed' as ImageDescriptionStatus }
                  : file,
              ),
            );
          }
        }
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : '处理失败';
        updateFileStatus(fileInfo.id, 'error', errorMessage);
        console.error(`Failed to process file ${fileInfo.id}:`, error);
      }
    },
    [autoGenerateDescription, context, rpdType, updateFileStatus, updateFileDescription, useTempStorage, sessionId],
  );

  // 上传文件
  const uploadFiles = useCallback(
    async (files: FileList | File[]) => {
      const fileArray = Array.from(files);

      // 创建文件信息对象
      const fileInfos: UploadFileInfo[] = fileArray.map((file) => ({
        id: generateId(),
        file,
        preview: createPreviewUrl(file),
        status: 'idle' as ImageDescriptionStatus,
      }));

      // 添加到状态中
      setUploadedFiles((prev) => [...prev, ...fileInfos]);

      // 控制并发数量，批量处理文件
      const chunks: UploadFileInfo[][] = [];
      for (let i = 0; i < fileInfos.length; i += maxConcurrentUploads) {
        chunks.push(fileInfos.slice(i, i + maxConcurrentUploads));
      }

      // 序列处理每个chunk，但chunk内部并发处理
      for (const chunk of chunks) {
        await Promise.allSettled(chunk.map(processFile));
      }
    },
    [generateId, createPreviewUrl, maxConcurrentUploads, processFile],
  );

  // 重新生成描述
  const regenerateDescription = useCallback(
    async (fileId: string, newContext?: string) => {
      const file = uploadedFiles.find((f) => f.id === fileId);
      if (!file || !file.s3Url) {
        console.error('File not found or no S3 URL available');
        return;
      }

      try {
        updateFileStatus(fileId, 'generating');

        const description = await assetsService.generateImageDescription({
          image_url: file.s3Url,
          context: newContext || context,
          rpd_type: rpdType,
          rpd_title: rpdTitle,
        });

        updateFileDescription(fileId, description);
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : '重新生成描述失败';
        updateFileStatus(fileId, 'error', errorMessage);
        console.error(`Failed to regenerate description for file ${fileId}:`, error);
      }
    },
    [uploadedFiles, context, rpdType, rpdTitle, updateFileStatus, updateFileDescription],
  );

  // 移除文件
  const removeFile = useCallback((fileId: string) => {
    setUploadedFiles((prev) => {
      const fileToRemove = prev.find((f) => f.id === fileId);
      if (fileToRemove && fileToRemove.preview.startsWith('blob:')) {
        URL.revokeObjectURL(fileToRemove.preview);
      }
      return prev.filter((f) => f.id !== fileId);
    });
  }, []);

  // 清空所有文件
  const clearFiles = useCallback(() => {
    setUploadedFiles((prev) => {
      // 清理所有blob URL
      prev.forEach((file) => {
        if (file.preview.startsWith('blob:')) {
          URL.revokeObjectURL(file.preview);
        }
      });
      return [];
    });
  }, []);

  // 获取文件描述
  const getFileDescription = useCallback(
    (fileId: string): GenerateImageDescriptionResponse | undefined => {
      const file = uploadedFiles.find((f) => f.id === fileId);
      return file?.description;
    },
    [uploadedFiles],
  );

  // 计算状态
  const uploadingCount = uploadedFiles.filter((f) => f.status === 'uploading').length;
  const generatingCount = uploadedFiles.filter((f) => f.status === 'generating').length;
  const isProcessing = uploadingCount > 0 || generatingCount > 0;

  return {
    uploadedFiles,
    uploadingCount,
    generatingCount,
    isProcessing,
    uploadFiles,
    regenerateDescription,
    removeFile,
    clearFiles,
    getFileDescription,
    updateFileStatus,
  };
};
