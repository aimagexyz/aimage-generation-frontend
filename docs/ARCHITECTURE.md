# Frontend Architecture

## Core Principles

1. **Single Source of Truth**: Each piece of logic exists in exactly one place
2. **Separation of Concerns**: API ≠ Service ≠ Hook ≠ Component
3. **Feature-Based Organization**: Group by business domain, not technical type
4. **High Cohesion, Low Coupling**: Related code stays together, modules stay independent
5. **Type Safety**: Zero escape hatches (`as unknown as` is forbidden)
6. **Simplicity**: Delete code > Add code. If it's not needed, delete it.

## Directory Structure

```
src/
├── api/                    # Raw API client (auto-generated, do not modify)
│   ├── client.ts           # Axios instance config
│   ├── schemas.d.ts        # OpenAPI generated types
│   └── *Service.ts         # Generated API methods
│
├── lib/                    # Framework-agnostic utilities
│   ├── auth.ts             # Token management, session handling
│   ├── date.ts             # Date utilities
│   ├── types.ts            # Truly global types (UUID, etc.)
│   └── ...                 # Other pure utilities
│
├── store/                  # Global state management
│   ├── queryClient.ts      # React Query config
│   ├── index.ts            # Zustand stores (UI state only)
│   └── middleware/         # Storage adapters
│
├── components/             # Global reusable UI components ONLY
│   ├── ui/                 # Base components (Button, Input, Modal)
│   └── layouts/            # Layout components (MainLayout, Sidebar)
│
├── hooks/                  # Global reusable hooks ONLY
│   ├── useDebounce.ts      # Generic debounce hook
│   └── useKeyboard.ts      # Generic keyboard hook
│
├── features/               # ALL business logic lives here
│   │
│   ├── tasks/              # Task management domain
│   │   ├── index.ts        # Public API (exports hooks, components)
│   │   ├── service.ts      # Business logic (pure TS, no React)
│   │   ├── hooks.ts        # React integration layer (thin)
│   │   ├── types.ts        # Domain-specific types
│   │   ├── components/     # Feature-specific components
│   │   │   └── TaskCard.tsx
│   │   └── TaskListPage.tsx
│   │
│   ├── ai-review/
│   │   ├── index.ts
│   │   ├── service.ts
│   │   ├── hooks.ts
│   │   ├── types.ts
│   │   ├── components/
│   │   │   ├── AiReviewPanel.tsx       (container, <300 lines)
│   │   │   ├── FindingsList.tsx
│   │   │   ├── FindingItem.tsx
│   │   │   └── ...
│   │   └── AiReviewPage.tsx
│   │
│   └── [other-features]/
│
├── App.tsx
└── main.tsx
```

## The Three-Layer Architecture

### Layer 1: API (`src/api/`)

**Purpose**: Raw data transport. Talk to backend, nothing else.

**Rules**:
- ❌ NEVER modify auto-generated files
- ❌ NEVER add business logic
- ❌ NEVER manage state
- ✅ ONLY HTTP requests and responses
- ✅ Use TypeScript types from `schemas.d.ts`

**Example**:
```typescript
// Generated by openapi-typescript
export const getTasks = (params: GetTasksParams) =>
  client.get('/api/v1/tasks', { params });
```

**DO NOT** create wrapper functions here. Use `fetchApi` from `client.ts` directly.

### Layer 2: Service (`src/features/*/service.ts`)

**Purpose**: Business logic. The brain of your feature.

**Rules**:
- ✅ Pure TypeScript functions (zero React dependencies)
- ✅ Import from `@/api/client` to make requests
- ✅ Handle data transformation, validation, error handling
- ✅ Contain ALL domain-specific business rules
- ❌ NEVER use React hooks
- ❌ NEVER manage UI state
- ❌ NEVER import from `components/`

**Size limit**: < 500 lines per file. Split if larger.

**Example**:
```typescript
// src/features/tasks/service.ts
import { fetchApi } from '@/api/client';
import type { TaskOut, TaskCreateInput } from '@/api/schemas';

export async function getTasks(projectId: string): Promise<TaskOut[]> {
  const response = await fetchApi({
    url: `/api/v1/projects/${projectId}/tasks` as const,
    method: 'get',
  });
  return response.data.items;
}

export async function deleteTask(taskId: string): Promise<void> {
  await fetchApi({
    url: `/api/v1/tasks/${taskId}` as const,
    method: 'delete',
  });
}

export async function validateTaskName(name: string): boolean {
  // Business rule: task names must be 3-100 chars
  return name.length >= 3 && name.length <= 100;
}
```

**Testing**: Services MUST be unit tested (they're pure functions).

### Layer 3: Hook (`src/features/*/hooks.ts`)

**Purpose**: Glue between Service and React. Handle UI concerns only.

**Rules**:
- ✅ Import from `./service.ts`
- ✅ Use `useQuery`/`useMutation` to call service functions
- ✅ Handle loading states, errors, cache invalidation
- ✅ Provide toast notifications
- ❌ NEVER implement business logic
- ❌ NEVER make direct API calls
- ❌ NEVER be > 100 lines

**Size limit**: < 100 lines per file. If larger, you're doing it wrong.

**Example**:
```typescript
// src/features/tasks/hooks.ts
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { toast } from 'sonner';
import * as tasksService from './service';

export function useTasks(projectId: string) {
  return useQuery({
    queryKey: ['tasks', projectId],
    queryFn: () => tasksService.getTasks(projectId),
    staleTime: 1000 * 60 * 5,
  });
}

export function useDeleteTask() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: tasksService.deleteTask,
    onSuccess: () => {
      toast.success('Task deleted');
      queryClient.invalidateQueries({ queryKey: ['tasks'] });
    },
    onError: (error: Error) => {
      toast.error(error.message);
    },
  });
}
```

### Layer 4: Component

**Purpose**: Render UI, dispatch events.

**Rules**:
- ✅ Import hooks from feature's `hooks.ts` or `index.ts`
- ✅ Handle user interactions
- ✅ Render UI
- ❌ NEVER call service functions directly
- ❌ NEVER make API calls
- ❌ NEVER contain business logic

**Size limit**: < 300 lines per file. < 200 lines preferred.

**Example**:
```typescript
// src/features/tasks/components/TaskCard.tsx
import { useDeleteTask } from '../hooks';

export function TaskCard({ task }) {
  const { mutate: deleteTask, isPending } = useDeleteTask();

  return (
    <div>
      <h3>{task.name}</h3>
      <button
        onClick={() => deleteTask(task.id)}
        disabled={isPending}
      >
        Delete
      </button>
    </div>
  );
}
```

## Feature Module Structure

Every feature MUST follow this exact structure:

```
src/features/[feature-name]/
├── index.ts              # REQUIRED: Public API, exports hooks & components
├── service.ts            # REQUIRED: Business logic
├── hooks.ts              # REQUIRED: React integration
├── types.ts              # REQUIRED: Domain types
├── components/           # OPTIONAL: Feature-specific components
│   └── *.tsx
└── [FeatureName]Page.tsx # OPTIONAL: Top-level page component
```

### index.ts Pattern

```typescript
// src/features/tasks/index.ts
export * from './hooks';
export * from './types';
export { TaskCard } from './components/TaskCard';
export { TaskListPage } from './TaskListPage';
// DO NOT export service.ts - it's internal
```

### Import Rules

**Within a feature**:
```typescript
// ✅ CORRECT: Relative imports
import { deleteTask } from './service';
import { useDeleteTask } from './hooks';
```

**From outside a feature**:
```typescript
// ✅ CORRECT: Import from index.ts
import { useDeleteTask, TaskCard } from '@/features/tasks';

// ❌ WRONG: Import internals
import { deleteTask } from '@/features/tasks/service';
```

## File Size Limits (ENFORCED)

| File Type | Max Lines | Rationale |
|-----------|-----------|-----------|
| Component | 300 | Beyond this, it's doing too much. Split it. |
| Hook | 100 | Thin glue layer. If > 100, logic belongs in Service. |
| Service | 500 | Core logic can be complex, but 500 is the hard limit. |
| Types | 200 | Type files grow fast. Split by subdomain if > 200. |

**Enforcement**: Pre-commit hook will reject files exceeding limits.

## Naming Conventions

### Files
- Components: `PascalCase.tsx` (TaskCard.tsx)
- Hooks: `camelCase.ts` or `use*.ts` (hooks.ts, useTaskDetail.ts)
- Services: `camelCase.ts` (service.ts, taskService.ts)
- Types: `camelCase.ts` (types.ts)

### Features
- Directory: `kebab-case` (task-tags, ai-review)
- Matches domain language, not tech jargon

### Functions
- Service functions: `verbNoun` (deleteTask, validateTaskName)
- Hooks: `useNoun` or `useVerbNoun` (useTasks, useDeleteTask)
- Components: `Noun` or `AdjectiveNoun` (TaskCard, CreateTaskModal)

## Type System Rules

### 1. NO Type Escape Hatches

```typescript
// ❌ FORBIDDEN
const data = response.data as unknown as MyType;
const data = response.data as any;

// ✅ CORRECT
import type { MyType } from '@/api/schemas';
const data: MyType = response.data; // Let TS verify compatibility
```

**Enforcement**: `as unknown as` triggers CI failure.

### 2. Use Generated Types

```typescript
// ❌ WRONG: Redefine types manually
interface Task {
  id: string;
  name: string;
}

// ✅ CORRECT: Use generated types
import type { TaskOut } from '@/api/schemas';
type Task = TaskOut;
```

### 3. Extend, Don't Duplicate

```typescript
// ✅ CORRECT: Extend generated types
import type { TaskOut } from '@/api/schemas';

export interface TaskWithMeta extends TaskOut {
  isSelected: boolean; // UI-only field
}
```

### 4. Co-locate Types

```typescript
// ❌ WRONG: Global types file for feature-specific types
// src/types/tasks.ts

// ✅ CORRECT: Types live with their feature
// src/features/tasks/types.ts
```

## State Management

### Server State (React Query)

**For**: Data from backend (tasks, users, settings)

```typescript
// ✅ CORRECT
export function useTasks(projectId: string) {
  return useQuery({
    queryKey: ['tasks', projectId],
    queryFn: () => tasksService.getTasks(projectId),
    staleTime: 1000 * 60 * 5, // 5 min cache
  });
}
```

**Cache invalidation**:
```typescript
// After mutation
queryClient.invalidateQueries({ queryKey: ['tasks'] });
```

### Client State (Zustand)

**For**: UI state only (sidebar open, theme, selected tab)

```typescript
// src/store/index.ts
import { create } from 'zustand';

interface UIState {
  sidebarOpen: boolean;
  toggleSidebar: () => void;
}

export const useUIStore = create<UIState>((set) => ({
  sidebarOpen: true,
  toggleSidebar: () => set((state) => ({ sidebarOpen: !state.sidebarOpen })),
}));
```

**DO NOT** use Zustand for server data.

### Local Component State (useState)

**For**: Temporary UI state (modal open, input value)

**Limit**: Max 5 `useState` per component. If more, extract sub-components.

```typescript
// ✅ CORRECT
function TaskCard() {
  const [isEditing, setIsEditing] = useState(false);
  // ...
}

// ❌ WRONG
function TaskDetail() {
  const [state1, setState1] = useState();
  const [state2, setState2] = useState();
  // ... 20 more useState
  // This is a code smell. Refactor.
}
```

## Anti-Patterns (FORBIDDEN)

### 1. God Components

```typescript
// ❌ FORBIDDEN: 2000+ line component
function AiReviewPanel() {
  // 2132 lines of horror
}

// ✅ CORRECT: Split into sub-components
function AiReviewPanel() {
  return (
    <>
      <FindingsList />
      <FindingFilters />
      <CitationView />
    </>
  );
}
```

### 2. Logic in Hooks

```typescript
// ❌ WRONG: Business logic in hook
export function useDeleteTask() {
  return useMutation({
    mutationFn: async (taskId) => {
      // Validation logic
      if (!taskId) throw new Error('Invalid ID');
      // API call
      await axios.delete(`/tasks/${taskId}`);
      // More logic...
    },
  });
}

// ✅ CORRECT: Logic in service, hook is thin
// service.ts
export async function deleteTask(taskId: string) {
  if (!taskId) throw new Error('Invalid ID');
  await fetchApi({ url: `/tasks/${taskId}`, method: 'delete' });
}

// hooks.ts
export function useDeleteTask() {
  return useMutation({
    mutationFn: tasksService.deleteTask, // Just wire it up
  });
}
```

### 3. Prop Drilling

```typescript
// ❌ WRONG: Passing props through 5 levels
<Parent>
  <Child1 data={data}>
    <Child2 data={data}>
      <Child3 data={data}>
        <Child4 data={data} />

// ✅ CORRECT: Use React Query or Context
// Child4.tsx
function Child4() {
  const { data } = useTasks(); // Fetch at consumption point
}
```

### 4. Duplicate API Calls

```typescript
// ❌ WRONG: Multiple hooks doing same thing
// useDeleteTaskFromList.ts
// useDeleteTaskFromDetail.ts
// useDeleteTaskAnywhere.ts

// ✅ CORRECT: One hook, reused everywhere
// hooks.ts
export function useDeleteTask() { ... }

// Usage in both places
import { useDeleteTask } from '@/features/tasks';
```

### 5. Feature Leakage

```typescript
// ❌ WRONG: tasks feature importing from ai-review feature
// src/features/tasks/service.ts
import { processAiReview } from '@/features/ai-review/service';

// ✅ CORRECT: If needed, create shared lib
// src/lib/ai-processing.ts
export function processAiReview() { ... }

// Both features import from lib
```

## Decision Tree

### "Where do I put this code?"

```
Is it a pure function with no side effects?
├─ Yes → Is it feature-specific?
│  ├─ Yes → features/[feature]/service.ts
│  └─ No → lib/[category].ts
└─ No → Does it need React lifecycle?
   ├─ Yes → Is it feature-specific?
   │  ├─ Yes → features/[feature]/hooks.ts
   │  └─ No → hooks/[generic-hook].ts
   └─ No → Is it UI rendering?
      ├─ Yes → Is it feature-specific?
      │  ├─ Yes → features/[feature]/components/
      │  └─ No → components/ui/
      └─ No → You're doing something wrong
```

### "Should I create a new feature or add to existing?"

```
Does this code relate to an existing feature's domain?
├─ Yes → Add to features/[existing]/
└─ No → Does it form a cohesive domain (>3 related components)?
   ├─ Yes → Create features/[new-feature]/
   └─ No → Put in appropriate global folder (lib/, components/, hooks/)
```

### "Should this be a Service function or Hook?"

```
Can this function run in Node.js without React?
├─ Yes → Service (business logic)
└─ No → Does it manage React state or lifecycle?
   ├─ Yes → Hook
   └─ No → Probably doesn't need to be either
```

## Migration Strategy

### For Existing Code

1. **Identify domain**: Which feature does this belong to?
2. **Extract service logic**: Move pure logic to `service.ts`
3. **Create thin hook**: Wrap service with `useQuery`/`useMutation`
4. **Move component**: Place in `components/` folder
5. **Update imports**: Change to use new paths
6. **Delete old files**: Remove original scattered files
7. **Test**: Verify feature still works
8. **Commit**: Small, focused commits

### For New Code

1. **Choose feature**: Which domain (tasks, ai-review, etc.)?
2. **Start with service**: Write business logic first (pure TS)
3. **Write tests**: Test service functions
4. **Add hook**: Thin React wrapper
5. **Build component**: Use the hook
6. **Export via index.ts**: Make it public

## Verification

### Pre-Commit Checks (Automated)

- [ ] No file > 500 lines
- [ ] No component > 300 lines
- [ ] No `as unknown as` in code
- [ ] All service files have tests
- [ ] TypeScript strict mode passes
- [ ] ESLint passes

### Code Review Checklist

- [ ] Code in correct layer (API/Service/Hook/Component)?
- [ ] Feature properly isolated?
- [ ] Types from generated schemas, not duplicated?
- [ ] Logic in Service, not Hook?
- [ ] Component < 300 lines?
- [ ] Hook < 100 lines?
- [ ] No prop drilling > 3 levels?
- [ ] Tests written for service functions?

## Examples

### Complete Feature Example: task-tags

```typescript
// src/features/task-tags/service.ts
import { fetchApi } from '@/api/client';
import type { TaskTagOut, TaskTagCreateInput } from '@/api/schemas';

export async function getTaskTags(projectId: string): Promise<TaskTagOut[]> {
  const response = await fetchApi({
    url: `/api/v1/projects/${projectId}/task-tags` as const,
    method: 'get',
  });
  return response.data.items;
}

export async function createTaskTag(
  projectId: string,
  input: TaskTagCreateInput
): Promise<TaskTagOut> {
  const response = await fetchApi({
    url: `/api/v1/projects/${projectId}/task-tags` as const,
    method: 'post',
    data: input,
  });
  return response.data;
}
```

```typescript
// src/features/task-tags/hooks.ts
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { toast } from 'sonner';
import * as taskTagsService from './service';
import type { TaskTagCreateInput } from '@/api/schemas';

export function useTaskTags(projectId: string) {
  return useQuery({
    queryKey: ['task-tags', projectId],
    queryFn: () => taskTagsService.getTaskTags(projectId),
  });
}

export function useCreateTaskTag(projectId: string) {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (input: TaskTagCreateInput) =>
      taskTagsService.createTaskTag(projectId, input),
    onSuccess: () => {
      toast.success('Tag created');
      queryClient.invalidateQueries({ queryKey: ['task-tags', projectId] });
    },
  });
}
```

```typescript
// src/features/task-tags/index.ts
export * from './hooks';
export * from './types';
```

```typescript
// Usage in component
import { useTaskTags, useCreateTaskTag } from '@/features/task-tags';

function TaskTagsManager({ projectId }: Props) {
  const { data: tags, isLoading } = useTaskTags(projectId);
  const { mutate: createTag } = useCreateTaskTag(projectId);

  return <>{/* UI */}</>;
}
```

## Appendix: Cheat Sheet

### Import Patterns

| From | To | Pattern |
|------|-----|---------|
| Anywhere | API | `import { fetchApi } from '@/api/client'` |
| Hook | Service | `import * as service from './service'` |
| Component | Hook | `import { useX } from '../hooks'` or `'@/features/x'` |
| Feature | Another Feature | `import { useX } from '@/features/y'` (via index.ts) |
| Anywhere | Lib | `import { formatDate } from '@/lib/date'` |

### Quick Reference

**"Can I import X from Y?"**
- ❌ Component → Service (use Hook instead)
- ❌ Service → Hook (circular dependency)
- ❌ Feature internals → Another feature (use public index.ts)
- ✅ Service → API
- ✅ Hook → Service
- ✅ Component → Hook
- ✅ Anything → Lib

**"What layer am I in?"**
- Writing `fetchApi`? → Service
- Writing `useQuery`? → Hook
- Writing JSX? → Component
- Writing pure function? → Service or Lib
